# 混杂随机时延Petri网建模软件使用说明书

## 1.简介

本软件是一套用于混杂随机时延Petri网（Hybrid Stochastic Timed Petri Net，HSTPN）建模与仿真推演的软件，能够用于包含离散、连续、随机、时延和决策中的一种或多种混杂特性的混杂系统的建模以及系统的仿真推演。

## 2.HSTPN模型设计过程

### 2.1 事件层设计

鼠标左键单击选择模块选择区的库所或变迁元素，然后在绘图区鼠标左键单击空白区域。鼠标左键单击选择模块选择区的有向弧元素，然后在绘图区鼠标左键单击库所或变迁元素，并保持鼠标左键按下，并移动至另一个库所或变迁元素，实现两者的连接。

在有向弧连接过程中，若出现“库所-库所”或“变迁-变迁”的连接方式，则系统会提示用户，该连接方式不合理。

### 2.2 物理层设计

该过程是针对每个库所进行属性设置，通过左键双击库所或右键单价库所并选择“属性”打开模型属性设置对话框。
**（1）激活状态**
选择库所的初始激活状态：
若该库所是HSTPN模型运行的第一个库所或者该库所没有前置变迁，则该库所的初始激活状态设为“true”，否则设为“false”；
**（2）概率阈值**
针对随机库所的属性设置。其中概率的产生方式有三种：
•	自定义方式：在“值”编辑框输入0~1范围内的数字，则随机库所以该值的概率产生结果1；
•	来自输入值方式：该方式需要在模型编辑器中相应的随机库所变量中提前设置好输入变量，然后在“变量”编辑框中选择相应的变量，随机库所以该变量值的概率产生结果1；
•	编程获取方式：单击“编码产生随机阈值”按钮，弹出Lua程序编辑界面，通过编程的方式产生概率值。在该方式中，需要注意变量的名称和顺序，其中“bcanEnable”、“random_num”和“step”分别列1、2、3位，如图所示。当bcanEnable=true时，库所才会使能，random_num表示随机库所产生结果1的概率，step表示步长。

**（3）时间阈值**
针对时延库所的属性设置。其中时延的产生方式有三种：
•	自定义时延：在“值”编辑框中输入一个正整数，则时延库所在激活后，经过正整数个时间单位才会使能；
•	来自输入值时延：定义方式同概率阈值；
•	随机时间：在右侧的两个编辑框中分别输入时延的下限和上限，则时延库所在该区间内的某个时间单位使能。
**（4）连续过程**：

单击自定义Lua脚本对话框，弹出Lua程序编辑界面，通过编程的方式实现连续过程的设计。在该方式中，需要注意变量的名称和顺序，其中“bcanEnable”和“step”分别列1、2位。

### 2.3 决策层设计

在模型属性设置对话框中，单击连续过程/决策过程下的自定义Lua脚本对话框，弹出Lua程序编辑界面，通过编程的方式实现决策过程的设计。在该方式中，需要注意变量的名称和顺序，其中“bcanEnable”、“step”和“tag”分别列1、2、3位。决策过程的本质是“if……else……”的过程，其中tag表示决策结果，该结果与决策库所后置变迁连接的有向弧标签对应，当tag的值与某个后置变迁的有向弧标签一致时，token流向相应的变迁，如图所示。需要指出的是，决策库所一次只能选择一条路径

### 2.4 变量定义

选择菜单栏“工具”，点击模型编辑器，打开模型编辑器对话框。
该对话框的左侧采用模型树的形式罗列出HSTPN模型的所有库所，单击模型树的根，则可设置全局变量，单击某个库所，可设置局部变量。

•	全局变量表：罗列了HSTPN模型中的全局变量，此类变量可以实现一次定义，实时更新，全局调用。全局变量的I/O类型为output，初始值可以自定义。
•	局部变量表：可以定义库所中的变量名、序号、I/O类型、引用全局、全局变量、数据源、初始值。
–	变量名：可与Lua脚本中变量名保持一致，也可自定义；
–	序号：变量定义的序号，该序号必须和Lua脚本中的变量顺序保持一致；
–	I/O类型：若该变量为库所内使用的变量，则定义为in/output类型，若为来自其他库所的变量，则为input类型。Output类型一般不用。需要注意一点的是，若该变量来自其他库所，但是在本库所中，变量值有变化，则该变量应设置为in/output类型。另外，变量类型的顺序应该为in/output类型→input类型，否则系统会报错，Lua脚本中库所I/O类型也应该遵循该顺序。
–	引用全局和全局变量：若该变量需要引用全局变量，则选择true，并选择相应的全局变量，但前提是全局变量表中存在该变量。如果不引用全局变量，则选择false和无。
–	数据源和数据源变量：若该变量是本库所内部使用的，则数据源选择本库所和相应的变量；若变量来自外部库所，则选择外部库所及其变量。
–	初始值：一般设为0，其值一般在Lua脚本中设置。

### 2.5 与Python端的连接过程

（1）客户端
首先，单击连接过程/决策过程的自定义Lua脚本按钮，弹出Lua编辑框，设置变量列表，变量的顺序为：
bcanEnable，step，tag，output1，output2，……，outputn，input1，input2，……，inputm。
在连接设置中，作出如下设置：
•	是否连接：选择“是”，则建立连接，选择“否”，则不建立连接；
•	IP地址：该地址与Python端Socket接口的IP地址保持一致；
•	端口号：同上；
•	输出变量数：Lua脚本中输出到Python端变量n的值；
•	输入变量数：Lua脚本中输入到HSTPNSim端变量m的值。
此处的输出变量和输入变量是针对HSTPNSim（客户端）和Python（服务器端）来说的。当然，从决策库所的角度来看，无论是输入变量还是输出变量，都是输入变量。

（2）服务器端
HSTPNSim传至Python端的值通过Socket通信的conn.recv()函数接收，通过决策程序给出的运行结果采用conn.send()函数发送至HSTPNSim。相应的Python端接口程序详见附件。
（3）运行过程
首先打开服务器端的决策程序，右键单击程序页标签，选择Run，运行服务器端程序，则调试框中会出现“Ready to connet”的提示。

鼠标左键单击HSTPNSim端的运行按钮，运行HSTPN模型，当决策库所被激活后，将输出变量的值传递给Python端，于此同时，Python端显示连接的端口号和connected，表示已建立连接，开始接收变量值，并将决策结果发送至HSTPNSim端。此时，决策库所使能，HSTPN模型继续运行。

附：Python端Socket接口程序
#导入相应的库文件
import socket
from SAE import load_model

**定义通信套接字**

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(('127.0.0.1', 4999))

**同时最大连接客户端数**

sock.listen(10)

**socket服务器监听**

**监听循环**

while True:
    print('ready to connect')
    conn, addr = sock.accept()  # 开始连接
    print(addr, 'connected')
    while True:
        try:
            buff = ''#清空接收堆栈
            # test_x = np.array((1, 39), dtype= float)
            # while len(buff) < 400:
            data = conn.recv(10)
            buff = data.decode()  # 接受信息
            print('recv:' + buff)
            result = load_model(int(buff))  # 决策模型 
            rebuff = str(result)  #决策结果
            conn.send(str(rebuff).encode())  # 发送决策结果至HSTPNSim
            buff = ''#清空接收堆栈
            print('send:' + rebuff)#打印发送的决策结果
        except Exception as e:
            print(e)
            break
    conn.close()  # 关闭连接

